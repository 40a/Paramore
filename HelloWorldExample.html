<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Explorations in architectural styles for .NET, Intended as reusable libraries, demos for training, and self-exploration</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
    </header>
    <section>
        <h3>Step One</h3>
        <p>Create a C# Console Application, targeting .NET 4.5. (Note that you can use any kind of host application, a console application is just the simplest way to get up and running in an example.</p>
        <h3>Step Two</h3>
        <p>Install the <strong>Paramore.Brighter.CommandProcessor</strong> package from NuGet</p>
        <ul>
            <li>PM> Install-Package Paramore.Brighter.CommandProcessor</li>
        </ul>
        <h4>Implementing a Handler Factory</h4>
        <p>Brighter builds a pipeline to handle requests. To do this it needs to create an instance of the target handler(s), and by inference your handler's dependencies.
        <p>A <em>Command Dispatcher</em> works by looking up registered handlers for the command or event and forwarding the request to them, i.e. publish-subscribe.</p>
        <p>For this, we need you to register your subscribers and published messages: you publish a Command or Event derived from <strong>IRequest</strong>;
            a subscribing handler derives from <strong>IHandleRequests&lt;TRequest&gt;</strong> where TRequest is the type of Command or Event you are subscribing to.
            You use the <em>SubscriberRegistry</em> class to register those subscriptions. So for a command <em>GreetingCommand</em> we expect you to register a type derived
            from <em>IHandleRequests&lt;GreetingCommand&gt;</em> using the Register method on the <strong>SubscriberRegistry</strong>
            e.g. <em>subscriberRegistry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;()</em>.</p>
        <p>Once we have found  one or more registered handlers for the type of the request we need to create instances of them.  This is complicated by your handler having its own dependencies
            which need to be created, which may have their own dependencies and so on. We don't know how to construct your handler so we call a factory, that you provide us, to build this entire
            dependency chain. This factory needs to implement the interface defined in <strong>IAmAHandlerFactory</strong>.</p>
        <p>Brighter manages the lifetimes of handlers, as we consider the request pipeline to be a scope, and we will call your factory again asking to release those handlers once we have terminated
            the pipeline and finished processing the request. You should take appropriate action to clear up the handler and its dependencies in response to that call</p>
        <p>It's worth reading Mark Seeman's article on <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI Friendly Frameworks</a> to understand this technique. Brighter originally
            used a conforming container but switched to user defined factories as per Mark's blog.</p>
        <p>In this case, the handler factory does not need to be implemented using an IoC container. We'll show that in a fuller example, but here it is trivial. For this simple program we just add
            this it the Program.cs file.</p>
                <pre><code>
internal class SimpleHandlerFactory : IAmAHandlerFactory
{
    private readonly ILog logger;

    public SimpleHandlerFactory(ILog logger)
    {
        this.logger = logger;
    }

    public IHandleRequests Create(Type handlerType)
    {
        return new GreetingCommandHandler(logger);
    }

    public void Release(IHandleRequests handler)
    {
    }
}
                </code></pre>
                <h3>Step Three</h3>
        <p>With this example creating an instance of the Command Processor is straightforward: as we provide a builder with a fluent interface to help you set up the builder. Because we ask
            you to provide factories where we need to create objects in your project, there are a number of items that you will need to configure. But you do this once, at the composition root,
            are then done with it.</p>
        <p>Add the following code to the Main class:</p>
         <pre><code>
 var properties = new NameValueCollection();
 properties["showDateTime"] = "true";
 LogManager.Adapter = new ConsoleOutLoggerFactoryAdapter(properties);
 var logger = LogManager.GetLogger(typeof (Program));

 var registry = new SubscriberRegistry();

 var builder = CommandProcessorBuilder.With()
     .Handlers(new HandlerConfiguration(
        subscriberRegistry: registry,
        handlerFactory: new SimpleHandlerFactory(logger)
     ))
    .NoPolicy()
    .Logger(logger)
    .NoTaskQueues()
    .RequestContextFactory(new InMemoryRequestContextFactory());

 var commandProcessor = builder.Build();
         </code></pre>
        <p>When we create a command processor we need the registry of subscribers to message types, and the factory for creating those handlers, that we discussed above.</p>
        <p> We also require a logger, which will give you diagnostic information about the processing of a message.</p>
        <p> Finally we want to give it a request context - a data structure passed to each handler in the chain, with global information including a property bag.
            Unless you have a need to override it, just use the default <strong>InMemoryRequestContextFactory</strong> to provide instances of a suitable context (overriding this is an advanced option
            - particularly useful for testing).</p>
        <p>Optionally we may include a registry of <a href="https://github.com/michael-wolfenden/Polly">Polly</a> policies,
            which you can use for Quality of Service issues (more elsewhere) and provide support for task queues - that is  handling work asynchronously by queuing it for later execution by one or
            or more worker processes). We do not need either here.</p>
        <h3>Step Four</h3>
        <h4>Our First Command</h4>
        <p>Now that you have a command processor, we want to create a message, and a handler for that message. We'll choose to implement a command, that in the finest tradition of demo applications
        just displays hello [name} on the console.</p>
        <p>Add a new class to the project called GreetingCommand and enter the following code:</p>
         <pre><code>
 class GreetingCommand : IRequest
 {
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
 }
         </code></pre>
        <h4>Our First Handler</h4>
        <p>Now that we have a Command we need to write a handler for it.</p>
        <p>We recommend using the RequestHandler abstract base class to implement your derived class from  <strong>IHandleRequests&lt;TRequest&gt;</strong> as it handles the basic responsibilities
        of a handler in the pipeline.</p>
        <p> Add a new class to the project called GreetingCommandHandler and then enter the following code:</p>
         <pre><code>
 class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
 {
    public GreetingCommandHandler(ILog logger) : base(logger) {}

    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return command;
    }
 }
         </code></pre>
        <p>You could directly implement the base class, but as we provide useful functionality to make sure that your handler participates in the handler pipeline correctly you
            should derive from this class unless you have a compelling reason to implement that support yourself.</p>
        <p>As each handler participates in the chain it is expected that you will return the input you were given, the command or event, so that the next handler in the chain
        can also process the request.</p>
        <p>In a 'real' application you would load your domain model's state from persistent storage here, process the request using your domain model and then save the
        state of the domain model. See <a href="CommandsCommandDispatcherandProcessor.html">Commands, Command Dispatcher and Processor</a> for more on this idiom.</p>
        <h3>Step Four</h3>
        <p>Having created a handler we have to tell Brighter about it. So we need to add it to the subscriber registry, we added above. Modify the code in Main as follows:</p>
        <pre><code>
var registry = new SubscriberRegistry();
registry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;();
        </code></pre>
        <h3>Step Five</h3>
        <p>Now that we have a handler registered, it is time to send it a message. The command processor exposes a send for point-to-point messaging (usually a command would have one
        handler), and publish for broadcast to zero or more handlers (usually an event has zero or more handlers)</p>
        <pre><code>
commandProcessor.Send(new GreetingCommand("Ian"));
        </code></pre>
        <h3>Step Six</h3>
        <p>let's just review the code. It's not a fine example of software development, but it serves to show you how Brighter works without any fuss</p>
        <pre><code>
class Program
{
    static void Main(string[] args)
    {
        var properties = new NameValueCollection();
        properties["showDateTime"] = "true";
        LogManager.Adapter = new ConsoleOutLoggerFactoryAdapter(properties);
        var logger = LogManager.GetLogger(typeof(Program));

        var registry = new SubscriberRegistry();
        registry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;();


        var builder = CommandProcessorBuilder.With()
            .Handlers(new HandlerConfiguration(
                subscriberRegistry: registry,
                handlerFactory: new SimpleHandlerFactory(logger)
             ))
            .NoPolicy()
            .Logger(logger)
            .NoTaskQueues()
            .RequestContextFactory(new InMemoryRequestContextFactory());

        var commandProcessor = builder.Build();

        commandProcessor.Send(new GreetingCommand("Ian"));
    }

    internal class SimpleHandlerFactory : IAmAHandlerFactory
    {
        private readonly ILog logger;

        public SimpleHandlerFactory(ILog logger)
        {
            this.logger = logger;
        }

        public IHandleRequests Create(Type handlerType)
        {
            return new GreetingCommandHandler(logger);
        }

        public void Release(IHandleRequests handler)
        {
        }
    }
}

class GreetingCommand : IRequest
{
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
}

class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
{
    public GreetingCommandHandler(ILog logger) : base(logger) {}

    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return command;
    }
}
        </code></pre>
        <h3>Step Seven</h3>
        <p>Now just build and run. You should see your greeting pumped out to the console.</p>
        <p>That is a brief introduction in how to get a command processor working. We explore a fuller example in <a href="TasksExample.html">Next Steps</a></p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>