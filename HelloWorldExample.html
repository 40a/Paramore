<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Explorations in architectural styles for .NET, Intended as reusable libraries, demos for training, and self-exploration</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
    </header>
    <section>
        <h3>Step One</h3>
        <p>Create a C# Console Application, targeting .NET 4.5. (Note that you can use any kind of host application, a console application is just the simplest way to get up and running in an example.</p>
        <h3>Step Two</h3>
        <p>Install the <strong>Paramore.Brighter.CommandProcessor</strong> package from NuGet</p>
        <ul>
            <li>PM> Install-Package Paramore.Brighter.CommandProcessor</li>
        </ul>
        <h4>Implementing a Handler Factory</h4>
        <p>Brighter builds a pipeline to handle requests. To do this it needs to create an instance of your handler(s), and by inference your handler's dependencies.
        <p>A <em>Command Dispatcher</em> works by looking up registered handlers for the command or event and forwarding the request to them. </p>
        <p>We need you to register Command or Event type derived from <strong>IRequest</strong> and their matching handler(s) types, derived from <strong>IHandleRequests<></strong> with us,
            using the <em>SubscriberRegistry</em> class. So for a command <em>GreetingCommand</em> we expect you to register a type derived from <em>IHandleRequests&lt;GreetingCommand&gt;</em>.</p>
        <p>Once we have found  one or more registered handlers for the type of the request we need to create instances of them.  This is complicated by your handler having its own dependencies
            which need to be created, which may have their own dependencies and so on. We don't know about these and so we call a factory that you provide us to builds this entire dependency chain,
            not just the handler.</p>
        <p>Brighter manage the lifetimes of handlers, as we are the request pipeline, and we will call your factory again asking to release those handlers once we have used them. You should take appropriate
            action to clear up the handler and its dependencies in that call</p>
        <p>It's worth reading Mark Seeman's article on <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI Friendly Frameworks</a> to understand this technique. Brighter originally
            used a conforming container but switched to user defined factories as per Mark's blog.</p>
        <p>In this case, the handler factory does not need to be implemented using an IoC container. We'll show that in a fuller example, but here it is trivial. For this simple program we just add
            this it the Program.cs file.</p>
                <pre><code>
internal class SimpleHandlerFactory : IAmAHandlerFactory
{
    private readonly ILog logger;

    public SimpleHandlerFactory(ILog logger)
    {
        this.logger = logger;
    }

    public IHandleRequests Create(Type handlerType)
    {
        return new GreetingCommandHandler(logger);
    }

    public void Release(IHandleRequests handler)
    {
    }
}
                </code></pre>
                <h3>Step Three</h3>
        <p>With this example creating an instance of the Command Processor is straightforward: as we provide a builder with a fluent interface to help you set up the builder. Because we ask
            you to provide factories where we need to create objects in your project, there are a number of items that you will need to configure. But you do this once, at the composition root,
            are then done with it.</p>
        <p>Add the following code to the Main class:</p>
         <pre><code>
 var properties = new NameValueCollection();
 properties["showDateTime"] = "true";
 LogManager.Adapter = new ConsoleOutLoggerFactoryAdapter(properties);
 var logger = LogManager.GetLogger(typeof (Program));

 var registry = new SubscriberRegistry();
 registry.Register<GreetingCommand, GreetingCommandHandler>();


 var builder = CommandProcessorBuilder.With()
     .Handlers(new HandlerConfiguration(
        subscriberRegistry: registry,
        handlerFactory: new SimpleHandlerFactory(logger)
     ))
    .NoPolicy()
    .Logger(logger)
    .NoTaskQueues()
    .RequestContextFactory(new InMemoryRequestContextFactory());

 var commandProcessor = builder.Build();
         </code></pre>
        <h3>Step Four</h3>
        <h4>Our First Command</h4>
        <p>Now that you have a command processor, we want to create a message, and a handler for that message. We'll choose to implement a command, that in the finest tradition of demo applications
        just displays hello [name} on the console.</p>
        <p>Add a new class to the project called GreetingCommand and enter the following code:</p>
         <pre><code>
 class GreetingCommand : IRequest
 {
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
 }
         </code></pre>
        <h4>Our First Handler</h4>
        <p>Now that we have a Command we need to write a handler for it. Add a new class to the project called GreetingCommandHandler and then enter the following code:</p>
         <pre><code>
 class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
 {
    public GreetingCommandHandler(ILog logger) : base(logger) {}

    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return command;
    }
 }
         </code></pre>
        <p>Note that we derive from RequestHandler here, and don't directly implement IHandleRequests<> You could directly implement the base class, but as we provide
        useful functionality to make sure that your handler participates in the handler pipeline correctly you should derive from this class unless you have a compelling
        reason to implement that support yourself.</p>
        <p>As each handler participates in the chain it is expected that you will return the input you were given, the command or event, so that the next handler in the chain
        can also process the request.</p>
        <p>In a 'real' application you would load your domain model's state from persistent storage here, process the request using your domain model and then save the
        state of the domain model. See <a href="CommandsCommandDispatcherandProcessor.html">Commands, Command Dispatcher and Processor</a> for more on this idiom.</p>
        <h3>Step Four</h3>
        <p>Having created a handler we have to tell Brighter about it. So we need to extract a variable for the container adapter from the builder's fluent interface,
            so that we can register handlers with the container</p>
        <pre><code>
var container = new TinyIoCAdapter(new TinyIoCContainer());
container.Register&lt;IHandleRequests&lt;GreetingCommand&gt;, GreetingCommandHandler&gt;();
        </code></pre>
        <h3>Step Five</h3>
        <p>Now that we have a handler registered, it is time to send it a message. The command processor exposes a send for point-to-point messaging (usually a command would have one
        handler), and publish for broadcast to zero or more handlers (usually an event has zero or more handlers)</p>
        <pre><code>
            commandProcessor.Send(new GreetingCommand("Ian"));
        </code></pre>
        <h3>Step Six</h3>
        <p>let's just review the code. It's not a fine example of software development, but it serves to show you how Brighter works without any fuss</p>
        <pre><code>
class Program
{
    static void Main(string[] args)
    {
        var properties = new NameValueCollection();
        properties["showDateTime"] = "true";
        LogManager.Adapter = new ConsoleOutLoggerFactoryAdapter(properties);
        var logger = LogManager.GetLogger(typeof(Program));

        var registry = new SubscriberRegistry();
        registry.Register&lt;GreetingCommand, GreetingCommandHandler&gt;();


        var builder = CommandProcessorBuilder.With()
            .Handlers(new HandlerConfiguration(
                subscriberRegistry: registry,
                handlerFactory: new SimpleHandlerFactory(logger)
             ))
            .NoPolicy()
            .Logger(logger)
            .NoTaskQueues()
            .RequestContextFactory(new InMemoryRequestContextFactory());

        var commandProcessor = builder.Build();

        commandProcessor.Send(new GreetingCommand("Ian"));
    }

    internal class SimpleHandlerFactory : IAmAHandlerFactory
    {
        private readonly ILog logger;

        public SimpleHandlerFactory(ILog logger)
        {
            this.logger = logger;
        }

        public IHandleRequests Create(Type handlerType)
        {
            return new GreetingCommandHandler(logger);
        }

        public void Release(IHandleRequests handler)
        {
        }
    }
}

class GreetingCommand : IRequest
{
    public GreetingCommand(string name)
    {
        Id = Guid.NewGuid();
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; private set; }
}

class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
{
    public GreetingCommandHandler(ILog logger) : base(logger) {}

    public override GreetingCommand Handle(GreetingCommand command)
    {
        Console.WriteLine("Hello {0}", command.Name);
        return command;
    }
}
        </code></pre>
        <h3>Step Seven</h3>
        <p>Now just build and run. You should see your greeting pumped out to the console.</p>
        <p>That is a brief introduction in how to get a command processor working. We explore a fuller example in <a href="TasksExample.html">Next Steps</a></p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>