<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Paramore by iancooper</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1>Paramore</h1>
        <p>Explorations of the Ports and Adapters and CQRS architectural styles for .NET, Intended as reusable libraries and supporting examples</p>
        <p class="view"><a href="https://github.com/iancooper/Paramore">View the Project on GitHub <small>iancooper/Paramore</small></a></p>
        <ul>
            <li><a href="https://github.com/iancooper/Paramore/zipball/master">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore/tarball/master">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/iancooper/Paramore">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="index.html">Paramore Home</a></p>
        <p><a href="Brighter.html">Brighter Home</a></p>
    </header>
    <section>
     <p>Once you are using the features of Brighter to act as a <a href="CommandsCommandDispatcherandProcessor.html">command dispatcher</a>  and send or publish messages to a target handler,
         you may want to use its  <a href="CommandsCommandDispatcherandProcessor.html">command processor</a> features to handle orthogonal operations.</p>
       <p>Common examples of orthogonal operations include:</p>
        <ul>
            <li>Logging the Command</li>
            <li>Providing integration with tools for monitoring performance and availability</li>
            <li>Validating the Command</li>
            <li>Supporting idempotency of messages</li>
            <li>Supporting resequencing of messages</li>
            <li>Handling exceptions</li>
            <li><a href="QualityOfServicePatterns.html"> Providing Timeout, Retry, and Circuit Breaker support</a></li>
            <li>Providing undo support, or rollback</li>
        </ul>
        <p>The first step in building a pipeline is to decide that we want an orthongonal operation in our pipeline. Let us assume that we want to do basic request logging.</p>
        <p>As described in <a href="ImplementingAHandler.html">Implementing a Handler</a> all handlers in the chain implement the same interface,
        <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/IHandleRequests.cs">IHandleRequests</a> ,
        and we recommend that you derive from <a href="https://github.com/iancooper/Paramore/blob/master/Brighter/paramore.brighter.commandprocessor/RequestHandler.cs">RequestHandlerT&lt;&gt;</a>
        as this ensures that you can call the next item in the chain using the base class Handle() method. </p>
        <p>Because you do not want to write an orthogonal handler for every Command or Event type, these handlers should remain generic types. At runtime the framework will handle creating an instance
        of the generic type for the type parameter of the Command or Event being passed along the pipeline. The limitation here is that you can only make assumptions about the type you receive into the
        pipeline from the constraints on the generic type.</p>
        <p>Let us assume that we want to log all requests travelling through the pipeline. (We provide this for you in the Paramore.Brighter.CommandProcessor packages so this for illustration only). We could
            implement a generic handler as follows:</p>
        <pre><code>
        using System;
        using Newtonsoft.Json;
        using paramore.brighter.commandprocessor.Logging;

        namespace paramore.brighter.commandprocessor
        {
            public class RequestLoggingHandler&lt;TRequest&gt;
                : RequestHandler&lt;TRequest&gt; where TRequest : class, IRequest
            {
                private HandlerTiming _timing;

                public RequestLoggingHandler(ILog logger)
                : base(logger)
                { }

                public override void InitializeFromAttributeParams(
                    params object[] initializerList
                )
                {
                    _timing = (HandlerTiming)initializerList[0];
                }

                public override TRequest Handle(TRequest command)
                {
                    LogCommand(command);
                    return base.Handle(command);
                }

                private void LogCommand(TRequest request)
                {
                    logger.InfoFormat(&quot;Logging handler pipeline call. Pipeline timing {0} target, for {1} with values of {2} at: {3}&quot;,
                        _timing.ToString(),
                        typeof(TRequest),
                        JsonConvert.SerializeObject(request),
                        DateTime.UtcNow);
                }
            }
        }
        </code></pre>
        <p>Note that as we rely on an user supplied implementation of <strong>IAmAHandlerFactory</strong> to instantiate Handlers (see the discussion <a href="HelloWorldExample.html">here</a>),
             you can have any dependencies in the constructor of your handler that you can resolve at runtime. In this case we pass in an ILog reference to actually log to.</p>
        <p>Our Handle method is the method which will be called by the pipeline to service the request. After we log we call <strong>return base.Handle(command)</strong>
            to ensure that the next handler in the chain is called. If we failed to do this, the <em>target handler</em> (the handler that exercises our domain model or transaction script) would not be called
            nor any subsequent handlers in the chain. This call to the next item in the chain is how we support the 'Russian Doll' model - because the next handler is called within the scope of this handler,
            we can manage when it is called handle exceptions, units of work, etc.</p>
        <p>We'll return to the purpose of <strong>InitializeFromAttributeParams</strong> a bit later.</p>
        <p>We now need to tell our pipeline to call this orthogonal handler before our target handler. To do this we use attributes. The code we want to write looks like this:</p>
        <pre><code>
            class GreetingCommandHandler : RequestHandler&lt;GreetingCommand&gt;
            {
                public GreetingCommandHandler(ILog logger) : base(logger) {}

                [RequestLogging(step: 1, timing: HandlerTiming.Before)]
                public override GreetingCommand Handle(GreetingCommand command)
                {
                    Console.WriteLine("Hello {0}", command.Name);
                    return base.Handle(command);
                }
            }
        </code></pre>
        <p>The <strong>RequestLogging</strong> Attribute tells the Command Processor to insert a Logging handler into the request handling pipeline before
            (<strong>HandlerTiming.Before</strong>) we run the target handler. It tells the Command Processor that we want it to be the first handler to run
            if we have multiple orthogonal handlers i.e. attributes (<strong>step: 1</strong>).</p>
        <p>We implement the <strong>RequestLoggingAttribute</strong> by creating our own Attribute class, derived from <strong>RequestHandlerAttribute</strong>.</p>
        <pre><code>
        public class RequestLoggingAttribute : RequestHandlerAttribute
        {
            public RequestLoggingAttribute(int step, HandlerTiming timing)
                : base(step, timing)
                { }

            public override object[] InitializerParams()
            {
                return new object[] { Timing };
            }

            public override Type GetHandlerType()
            {
                return typeof(RequestLoggingHandler&lt;&gt;);
            }
        }

        </code></pre>
        <p>The most important part of this implementation is the GetHandlerType() method, where we return the type of our handler. This is what the Command Processor uses
            to request an instance of your type from your <strong>Handler Factory</strong>.</p>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/iancooper">iancooper</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
    </footer>
</div>
<script src="javascripts/scale.fix.js"></script>
</body>
</html>